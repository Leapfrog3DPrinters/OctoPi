#!/bin/bash
# Author: Erik Heidstra <ErikHeidstra@live.nl>
# Monitors the factory reset process, by polling dd
# A PNG image is pushed to the framebuffer that displays the current status

# Backup files
mountdir="/backup"
rootbackup="root.img.gz"
homebackup="home.img.gz"

# Layout
progressimg="/usr/share/factoryreset/lpfrg-factoryreset-portrait.png"
outputimg="/usr/share/factoryreset/progress"
fontfile="/usr/share/factoryreset/AdventPro-Bold.ttf"
fontcolor="#95C200"
fontsize=55

# Files indicating the status of the factory reset procedure
statusfile="/var/run/factoryresetstatus"
stepfile="/var/run/factoryresetstep"

# Figure out the resettype
resettypefile="/boot/factoryreset.txt"
resettype=$(< $resettypefile)

# Monitoring interval in seconds
interval=3

# Wait for the directory to be mounted and read the uncompressed size of the backupimages
while [ -z "$rootsize" ]; do
  rootsize=$(gzip -l "$mountdir/$rootbackup" | tail -1 | awk '{print $2}')
  homesize=$(gzip -l "$mountdir/$homebackup" | tail -1 | awk '{print $2}')
  sleep 2
done

if [ "$resettype" == "full" ]; then
  totalsize=$(($rootsize+$homesize))
elif [ "$resettype" == "fast" ]; then
  totalsize=$homesize
else
  echo "Resettype not recognized, must be fast or full. Found: $resettype"
  exit 1
fi

# Using this little trick we can auto-refresh one image in FBI
#https://raspberrypi.stackexchange.com/questions/24180/how-can-i-refresh-image-displayed-by-fbi-without-black-screen-transition
i="a"
cp -f "$progressimg" "$outputimg$i.png"
ln -f --symbolic "$outputimg$i.png" "$outputimg-sym0.png" 
ln -f --symbolic "$outputimg$i.png" "$outputimg-sym1.png" 
ln -f --symbolic "$outputimg$i.png" "$outputimg-sym2.png"

# Display on tty7 and refresh every 3 sec
# Don't read the output img itself (due to race condition)
fbi -noverbose --autodown -d /dev/fb0 -T 7 --noreadahead --cachemem 0 -t $interval "$outputimg-sym0.png" "$outputimg-sym1.png" "$outputimg-sym2.png"&
fbipid=$!

# Begin the monitoring loop
while true; do

    # Reset progress string
    progressstr=""

    # Read the current step of the procedure
    step=$(< $stepfile)

    # Find dd process
    pid=$(pgrep ^dd)

    if [ -n "$pid" ]; then
      # Ask for an update (stored in $statusfile)
      kill -USR1 $pid

      # Read last line of statusfile
      status=$(tail -1 "$statusfile" | awk '{print $1}')

      # Make a nice string representation of the status
      if [ "$step" == "root" ]; then
          progress=$(($status * 100 / $totalsize))
      elif [ "$step" == "home" ] && [ "$resettype" == "full" ]; then
          progress=$(( ($status + $rootsize) * 100 / $totalsize ))
      else
          progress=$(($status * 100 / $totalsize))
      fi
      
      progressstr="${progress}%"
    else
      if [ "$step" == "boot" ]; then
        progressstr="Rebooting..."
      fi
    fi

    # Toggle $i between a/b (double buffering!)
    if [ "$i" == "a" ]; then
      i="b"
    elif [ "$i" == "b" ]; then
      i="a"
    fi

    # Make an overlay with the progress string and save it to disk
    convert "$progressimg" -fill "$fontcolor" -font "$fontfile" -pointsize "$fontsize" -gravity Center \
    -draw "text 0,400 '${progressstr}'" \
    "$outputimg$i.png"

    # Update the symlinks
    ln -f --symbolic "$outputimg$i.png" "$outputimg-sym0.png" 
    ln -f --symbolic "$outputimg$i.png" "$outputimg-sym1.png" 
    ln -f --symbolic "$outputimg$i.png" "$outputimg-sym2.png"

    if [ "$step" == "boot" ]; then
      exit 0
    else
      sleep $interval
    fi
    
done 