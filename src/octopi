#!/usr/bin/env bash
# OctoPi generation script
# This script takes a Raspbian image and adds to it octoprint and verions addons
# Written by Guy Sheffer <guysoft at gmail dot com>
# GPL V3

source $OCTOPI_SCRIPT_PATH/common.sh

function execute_chroot_script() {
  #move OctoPi filesystem files
  cp -vr --preserve=mode,timestamps $1/filesystem .

  #black magic of qemu-arm-static
  cp `which qemu-arm-static` usr/bin
  
  cp $2 chroot_script
  chmod 755 chroot_script
  cp $OCTOPI_SCRIPT_PATH/common.sh common.sh
  chmod 755 common.sh
  
  chroot . usr/bin/qemu-arm-static /bin/bash /chroot_script
  
  #cleanup
  rm chroot_script
  rm -rfv filesystem
}

mkdir -p $OCTOPI_WORKSPACE
mkdir -p $OCTOPI_MOUNT_PATH

install_cleanup_trap
install_fail_on_error_trap $OCTOPI_MOUNT_PATH
unmount_image $OCTOPI_MOUNT_PATH force || true

pushd $OCTOPI_WORKSPACE
  if [ -e *.img ]; then  
    rm *.img
  fi
  unzip $OCTOPI_ZIP_IMG
  OCTOPI_IMG_PATH=`ls | grep '.img\|.raw' | head -n 1`
  export OCTOPI_BUILDBASE=$(basename $OCTOPI_IMG_PATH)

  if [ "$OCTOPI_IMAGE_RECOVERY" == "yes" ]
  then
    # Make a copy of the raspbian image, to be included on the recovery partition 
    OCTOPI_RECOVERY_IMG="${OCTOPI_BUILDBASE%.*}_recovery.img"
    cp -f $OCTOPI_IMG_PATH $OCTOPI_RECOVERY_IMG
  fi

  if [ -n "$OCTOPI_IMAGE_ENLARGEROOT" ]
  then
    # make our image a bit larger so we don't run into size problems...
    enlarge_ext $OCTOPI_IMG_PATH $OCTOPI_ROOT_PARTITION $OCTOPI_IMAGE_ENLARGEROOT
  fi

  if [ "$OCTOPI_IMAGE_RECOVERY" == "yes" ]
  then
    recovery_partition=$(($OCTOPI_ROOT_PARTITION + 1))
    backup_size=$OCTOPI_IMAGE_BACKUPPARTITION_SIZE
    recovery_size=$OCTOPI_IMAGE_RECOVERYPARTITION_SIZE

    backup_partition_num=5
    recovery_partition_num=6

    if [ -n "$OCTOPI_IMAGE_HOMEPARTITION_SIZE" ]; then
       #Recovery partitions with home partition
      home_size=$OCTOPI_IMAGE_HOMEPARTITION_SIZE
      total_size=$(($backup_size + $recovery_size + $home_size))

      home_partition_num=7

      add_extended_ext $OCTOPI_IMG_PATH $recovery_partition $total_size

      add_logical_ext $OCTOPI_IMG_PATH $backup_partition_num $backup_size
      add_logical_ext $OCTOPI_IMG_PATH $recovery_partition_num $recovery_size
      add_logical_ext $OCTOPI_IMG_PATH $home_partition_num $home_size

      include_recovery_partition $OCTOPI_IMG_PATH $recovery_partition_num $OCTOPI_RECOVERY_IMG $OCTOPI_RECOVERY_ROOT_PARTITION

      rm $OCTOPI_RECOVERY_IMG

      mount_image $OCTOPI_IMG_PATH $OCTOPI_ROOT_PARTITION $OCTOPI_MOUNT_PATH $home_partition_num

    else

      total_size=$(($backup_size + $recovery_size))

      add_extended_ext $OCTOPI_IMG_PATH $recovery_partition $total_size

      add_logical_ext $OCTOPI_IMG_PATH $backup_partition_num $backup_size
      add_logical_ext $OCTOPI_IMG_PATH $recovery_partition_num $recovery_size

      mount_image $OCTOPI_IMG_PATH $OCTOPI_ROOT_PARTITION $OCTOPI_MOUNT_PATH
    fi

  elif [ -n "$OCTOPI_IMAGE_HOMEPARTITION_SIZE" ]; then
    # Find home partition number
    home_partition_num=$(($OCTOPI_ROOT_PARTITION + 1))

    # Add it to the image
    add_ext $OCTOPI_IMG_PATH $home_partition_num $OCTOPI_IMAGE_HOMEPARTITION_SIZE

    # mount root, home and boot partition
    mount_image $OCTOPI_IMG_PATH $OCTOPI_ROOT_PARTITION $OCTOPI_MOUNT_PATH $home_partition_num

  else
    # mount root and boot partition
    mount_image $OCTOPI_IMG_PATH $OCTOPI_ROOT_PARTITION $OCTOPI_MOUNT_PATH   
  fi

  if [ -n "$OCTOPI_APT_CACHE" ]
  then
    mkdir -p "$OCTOPI_APT_CACHE"
    mount --bind "$OCTOPI_APT_CACHE" $OCTOPI_MOUNT_PATH/var/cache/apt
  fi

  # Edit pi filesystem
  pushd $OCTOPI_MOUNT_PATH

    #make QEMU boot (remember to return)
    if [ "$OCTOPI_IMAGE_RASPBIAN" == "yes" ]; then
      fixLd
    fi

    # As of April 2017, fstab uses UUIDs to identify the first two partitions.
    # The first boot will however use parted->resizepart to recreate the partition table
    # which changes the UUID. Therefore, we replace the UUIDs here by their device
    # path representations. 
    sed -i "s@PARTUUID=[a-zA-Z0-9]*-0\([0-9]\)@/dev/mmcblk0p\1@" etc/fstab

    #Edit fstab to account for the new home partition
    if [ -n "$OCTOPI_IMAGE_HOMEPARTITION_SIZE" ]
    then
      # No automount. This will be set after the partition has been resized.
      sed -i "3 a /dev/mmcblk0p$home_partition_num /home ext4 rw,user,noauto,exec 0 2" etc/fstab
    fi

    # Prevent automount of backup and recovery partitions
    if [ "$OCTOPI_IMAGE_RECOVERY" == "yes" ]
    then
      sed -i "4 a /dev/mmcblk0p$backup_partition_num /backups ext4 uid=0,owner,noauto,ro 0 2" etc/fstab
      sed -i "5 a /dev/mmcblk0p$recovery_partition_num /recoveryroot ext4 uid=0,owner,noauto,ro 0 2" etc/fstab
    fi

    # if an additional pre-script is defined, execute that now
    if [ -n "$OCTOPI_PRESCRIPT" ] && [ -f $OCTOPI_PRESCRIPT/chroot_script ]; then
      echo "Injecting environment pre script from $OCTOPI_PRESCRIPT..."
      execute_chroot_script $OCTOPI_PRESCRIPT $OCTOPI_PRESCRIPT/chroot_script
    fi

    # if building a variant, execute its pre-chroot script
    if [ -n "$VARIANT_BASE" ] && [ -f $VARIANT_BASE/pre_chroot_script ]; then
      echo "Injecting variant pre script from $VARIANT_BASE..."
      execute_chroot_script $VARIANT_BASE $VARIANT_BASE/pre_chroot_script
    fi
 
    # execute the base chroot script
    execute_chroot_script $OCTOPI_SCRIPT_PATH $OCTOPI_CHROOT_SCRIPT_PATH
    
    # if building a variant, execute its post-chroot script
    if [ -n "$VARIANT_BASE" ] && [ -f $VARIANT_BASE/post_chroot_script ]; then
      echo "Injecting variant post script from $VARIANT_BASE..."
      execute_chroot_script $VARIANT_BASE $VARIANT_BASE/post_chroot_script
    fi

    # if an additional post-script is defined, execute that now
    if [ -n "$OCTOPI_POSTSCRIPT" ] && [ -f $OCTOPI_POSTSCRIPT/chroot_script ]; then
      echo "Injecting environment post script from $OCTOPI_POSTSCRIPT..."
      execute_chroot_script $OCTOPI_POSTSCRIPT $OCTOPI_POSTSCRIPT/chroot_script
    fi
    if [ "$OCTOPI_IMAGE_RASPBIAN" == "yes" ]; then
      restoreLd
    fi
  popd
  
  # unmount first boot, then root partition
  unmount_image $OCTOPI_MOUNT_PATH
  chmod 777 $OCTOPI_IMG_PATH

  if [ "$OCTOPI_IMAGE_RECOVERY" == "yes" ]
  then
    echo "--- Mounting recovery partition"
    mkdir -p "$OCTOPI_MOUNT_PATH/boot"
    mkdir -p "bootbackup"

    mount_image $OCTOPI_IMG_PATH $recovery_partition_num $OCTOPI_MOUNT_PATH

    # We already have access to the boot partition here, so lets leverage that to make a backup of the important files
    for fn in "${OCTOPI_RECOVERY_BOOT_FILES[@]}"; do
      if [ -f "$OCTOPI_MOUNT_PATH/boot/$fn" ]; then
        cp -f "$OCTOPI_MOUNT_PATH/boot/$fn" "bootbackup/$fn"
      fi
    done
    
    pushd $OCTOPI_MOUNT_PATH
      # Same fstab fix as on main partition (UUID > /dev/...)
      sed -i "s@PARTUUID=[a-zA-Z0-9]*-0\([0-9]\)@/dev/mmcblk0p\1@" etc/fstab

      echo "--- Executing recovery partition chroot script"
      fixLd
      execute_chroot_script $OCTOPI_SCRIPT_PATH $OCTOPI_RECOVERY_CHROOT_SCRIPT_PATH
      restoreLd
    popd
    unmount_image $OCTOPI_MOUNT_PATH
    chmod 777 $OCTOPI_IMG_PATH

    echo "--- Mounting backup partition"
    mount_partition $OCTOPI_IMG_PATH $backup_partition_num $OCTOPI_MOUNT_PATH

    echo "--- Creating backups"
    backup_partition $OCTOPI_IMG_PATH $OCTOPI_ROOT_PARTITION "$OCTOPI_MOUNT_PATH/root.img.gz"
    backup_partition $OCTOPI_IMG_PATH $home_partition_num "$OCTOPI_MOUNT_PATH/home.img.gz"
    mv "bootbackup" "$OCTOPI_MOUNT_PATH/bootbackup"

    unmount_partition $OCTOPI_MOUNT_PATH

  elif [ -n "$OCTOPI_IMAGE_RESIZEROOT" ]
    then
      # resize image to minimal size + provided size
      minimize_ext $OCTOPI_IMG_PATH $OCTOPI_ROOT_PARTITION $OCTOPI_IMAGE_RESIZEROOT
  fi

  
popd

